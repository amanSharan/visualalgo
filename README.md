# Visual Algorithm



Visual Algo (Web devlopment)

By

Aman Sharan

18VBCA037716
            

Department of Computer Science

St. Xavierâ€™s College, Ranchi

2021



Title of the Project

Visual Algorithm 

Objective of the Project

The Web Application is based on various algorithms and used to visualize them in action.At its core, a visual algorithm seeks to find the shortest path between two points. This application visualizes various pathfinding algorithms in action, and more!
Project Category


Web Based Application(Responsive)



Software Requirements

Operating System
Editor(VS code)
terminal(git-bash)
node.js
Browser 

Hardware Requirements

Processor Capacity:- Runs on most of the processor 
RAM Capacity:- 2gb or more
Graphics Card Capacity:- Default(no need of high end graphic card)
HDD Capacity:-Default

Languages to be used

Front End
HTML
Css
javascript

Back End

node
Templeting(EJS)
express


Methodology

The application is a web application program.Here the visualization of the algorithm is done by grid view . All of the algorithms on this application are adapted for a 2D grid, where 90 degree turns have a "cost" of 1 and movements from a node to another have a "cost" of 1.Varios maze and patterns are given under the maze & pattern drop down menu,choose from the list to generate different path blockers and use visualise to view different Algorithm in action.

Modules

Algorithm
Visualize
Maze and patterns
Weighted node
Walls
Add bombs


Meet the Algorithms
This application supports the following algorithms:
Dijkstra's Algorithm (weighted): the father of pathfinding algorithms; guarantees the shortest path
A Search* (weighted): arguably the best pathfinding algorithm; uses heuristics to guarantee the shortest path much faster than Dijkstra's Algorithm
Greedy Best-first Search (weighted): a faster, more heuristic-heavy version of A*; does not guarantee the shortest path
Swarm Algorithm (weighted): a mixture of Dijkstra's Algorithm and A*; does not guarantee the shortest-path
Convergent Swarm Algorithm (weighted): the faster, more heuristic-heavy version of Swarm; does not guarantee the shortest path
Bidirectional Swarm Algorithm (weighted): Swarm from both sides; does not guarantee the shortest path
Breadth-first Search (unweighted): a great algorithm; guarantees the shortest path
Depth-first Search (unweighted): a very bad algorithm for pathfinding; does not guarantee the shortest path
On top of the pathfinding algorithms listed above, I implemented a Recursive Division Maze Generation algorithm.


Benefits


The main objective of the proposed application is to visualize various algorithms. The application can be handy to the user in the following reasons:

To understand the algorithm working.
It can also be used to generalise the best case and the worst case of an Algorithm. 




-----:-----
